"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[43838],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return f}});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),d=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=d(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=d(n),f=i,m=p["".concat(l,".").concat(f)]||p[f]||u[f]||a;return n?r.createElement(m,o(o({ref:t},c),{},{components:n})):r.createElement(m,o({ref:t},c))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var d=2;d<a;d++)o[d]=n[d];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},46526:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return f},frontMatter:function(){return s},metadata:function(){return d},toc:function(){return u}});var r=n(87462),i=n(63366),a=(n(67294),n(3905)),o=["components"],s={id:"processTargets_modifiers_surroundingPair_findDelimiterPairContainingSelection",title:"Module: processTargets/modifiers/surroundingPair/findDelimiterPairContainingSelection",sidebar_label:"processTargets/modifiers/surroundingPair/findDelimiterPairContainingSelection",sidebar_position:0,custom_edit_url:null},l=void 0,d={unversionedId:"contributing/api/modules/processTargets_modifiers_surroundingPair_findDelimiterPairContainingSelection",id:"contributing/api/modules/processTargets_modifiers_surroundingPair_findDelimiterPairContainingSelection",title:"Module: processTargets/modifiers/surroundingPair/findDelimiterPairContainingSelection",description:"Functions",source:"@site/../docs/contributing/api/modules/processTargets_modifiers_surroundingPair_findDelimiterPairContainingSelection.md",sourceDirName:"contributing/api/modules",slug:"/contributing/api/modules/processTargets_modifiers_surroundingPair_findDelimiterPairContainingSelection",permalink:"/docs/contributing/api/modules/processTargets_modifiers_surroundingPair_findDelimiterPairContainingSelection",editUrl:null,tags:[],version:"current",sidebarPosition:0,frontMatter:{id:"processTargets_modifiers_surroundingPair_findDelimiterPairContainingSelection",title:"Module: processTargets/modifiers/surroundingPair/findDelimiterPairContainingSelection",sidebar_label:"processTargets/modifiers/surroundingPair/findDelimiterPairContainingSelection",sidebar_position:0,custom_edit_url:null},sidebar:"contributing",previous:{title:"processTargets/modifiers/surroundingPair/findDelimiterPairAdjacentToSelection",permalink:"/docs/contributing/api/modules/processTargets_modifiers_surroundingPair_findDelimiterPairAdjacentToSelection"},next:{title:"processTargets/modifiers/surroundingPair/findOppositeDelimiter",permalink:"/docs/contributing/api/modules/processTargets_modifiers_surroundingPair_findOppositeDelimiter"}},c={},u=[{value:"Functions",id:"functions",level:2},{value:"findDelimiterPairContainingSelection",id:"finddelimiterpaircontainingselection",level:3},{value:"Parameters",id:"parameters",level:4},{value:"Returns",id:"returns",level:4},{value:"Defined in",id:"defined-in",level:4}],p={toc:u};function f(e){var t=e.components,n=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"functions"},"Functions"),(0,a.kt)("h3",{id:"finddelimiterpaircontainingselection"},"findDelimiterPairContainingSelection"),(0,a.kt)("p",null,"\u25b8 ",(0,a.kt)("strong",{parentName:"p"},"findDelimiterPairContainingSelection"),"(",(0,a.kt)("inlineCode",{parentName:"p"},"initialIndex"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"delimiterOccurrences"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"acceptableDelimiters"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"selectionOffsets"),"): ",(0,a.kt)("a",{parentName:"p",href:"/docs/contributing/api/interfaces/processTargets_modifiers_surroundingPair_types.SurroundingPairOffsets"},(0,a.kt)("inlineCode",{parentName:"a"},"SurroundingPairOffsets"))," ","|"," ",(0,a.kt)("inlineCode",{parentName:"p"},"null")),(0,a.kt)("p",null,"Looks for a surrounding pair that contains the selection, returning null if none is found."),(0,a.kt)("p",null,"Our approach is to first initialize two generators, one scanning rightwards\nand one scanning leftwards.  The generator scanning rightwards starts at the\nfirst delimiter whose end offset is greater than or equal to the end offset\nof the selection.  The generator scanning leftwards starts at the token just\nprior to the start token for the rightward scanner."),(0,a.kt)("p",null,"We start with the right generator, proceeding until we find any acceptable\nunmatched closing delimiter.  We then advance the left generator, looking\nonly for an unmatched opening delimiter that matches the closing delimiter\nwe found in our rightward scan."),(0,a.kt)("p",null,"If the delimiter found by our leftward scan is before or equal to the start\nof the selection, we return the delimiter pair.  If not, we loop back and\nscan left / right again, repeating the process until our leftward or\nrightward scan runs out of delimiters."),(0,a.kt)("h4",{id:"parameters"},"Parameters"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,a.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,a.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"initialIndex")),(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"number")),(0,a.kt)("td",{parentName:"tr",align:"left"},"The index of the first delimiter to try within the delimiter occurrences list.  Expected to be the index of the first delimiter whose end offset is greater than or equal to the end offset of the selection.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"delimiterOccurrences")),(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("a",{parentName:"td",href:"/docs/contributing/api/interfaces/processTargets_modifiers_surroundingPair_types.PossibleDelimiterOccurrence"},(0,a.kt)("inlineCode",{parentName:"a"},"PossibleDelimiterOccurrence")),"[]"),(0,a.kt)("td",{parentName:"tr",align:"left"},"A list of delimiter occurrences.  Expected to be sorted by offsets")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"acceptableDelimiters")),(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("a",{parentName:"td",href:"/docs/contributing/api/modules/typings_targetDescriptor_types#simplesurroundingpairname"},(0,a.kt)("inlineCode",{parentName:"a"},"SimpleSurroundingPairName")),"[]"),(0,a.kt)("td",{parentName:"tr",align:"left"},"A list of names of acceptable delimiters to look for")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"selectionOffsets")),(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("a",{parentName:"td",href:"/docs/contributing/api/interfaces/processTargets_modifiers_surroundingPair_types.Offsets"},(0,a.kt)("inlineCode",{parentName:"a"},"Offsets"))),(0,a.kt)("td",{parentName:"tr",align:"left"},"The offsets of the selection")))),(0,a.kt)("h4",{id:"returns"},"Returns"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/contributing/api/interfaces/processTargets_modifiers_surroundingPair_types.SurroundingPairOffsets"},(0,a.kt)("inlineCode",{parentName:"a"},"SurroundingPairOffsets"))," ","|"," ",(0,a.kt)("inlineCode",{parentName:"p"},"null")),(0,a.kt)("p",null,"The offsets of the surrounding pair containing the selection, or\nnull if none is found"),(0,a.kt)("h4",{id:"defined-in"},"Defined in"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/cursorless-dev/cursorless/blob/ed5840d/src/processTargets/modifiers/surroundingPair/findDelimiterPairContainingSelection.ts#L38"},"src/processTargets/modifiers/surroundingPair/findDelimiterPairContainingSelection.ts:38")))}f.isMDXComponent=!0}}]);