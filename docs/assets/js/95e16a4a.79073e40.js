"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[84345],{3905:function(e,r,t){t.d(r,{Zo:function(){return l},kt:function(){return g}});var n=t(67294);function i(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function a(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function o(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?a(Object(t),!0).forEach((function(r){i(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function s(e,r){if(null==e)return{};var t,n,i=function(e,r){if(null==e)return{};var t,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)t=a[n],r.indexOf(t)>=0||(i[t]=e[t]);return i}(e,r);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)t=a[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var d=n.createContext({}),u=function(e){var r=n.useContext(d),t=r;return e&&(t="function"==typeof e?e(r):o(o({},r),e)),t},l=function(e){var r=u(e.components);return n.createElement(d.Provider,{value:r},e.children)},p={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},c=n.forwardRef((function(e,r){var t=e.components,i=e.mdxType,a=e.originalType,d=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),c=u(t),g=i,f=c["".concat(d,".").concat(g)]||c[g]||p[g]||a;return t?n.createElement(f,o(o({ref:r},l),{},{components:t})):n.createElement(f,o({ref:r},l))}));function g(e,r){var t=arguments,i=r&&r.mdxType;if("string"==typeof e||i){var a=t.length,o=new Array(a);o[0]=c;var s={};for(var d in r)hasOwnProperty.call(r,d)&&(s[d]=r[d]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var u=2;u<a;u++)o[u]=t[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,t)}c.displayName="MDXCreateElement"},82787:function(e,r,t){t.r(r),t.d(r,{assets:function(){return l},contentTitle:function(){return d},default:function(){return g},frontMatter:function(){return s},metadata:function(){return u},toc:function(){return p}});var n=t(87462),i=t(63366),a=(t(67294),t(3905)),o=["components"],s={id:"processTargets_modifiers_surroundingPair_findSurroundingPairParseTreeBased",title:"Module: processTargets/modifiers/surroundingPair/findSurroundingPairParseTreeBased",sidebar_label:"processTargets/modifiers/surroundingPair/findSurroundingPairParseTreeBased",sidebar_position:0,custom_edit_url:null},d=void 0,u={unversionedId:"contributing/api/modules/processTargets_modifiers_surroundingPair_findSurroundingPairParseTreeBased",id:"contributing/api/modules/processTargets_modifiers_surroundingPair_findSurroundingPairParseTreeBased",title:"Module: processTargets/modifiers/surroundingPair/findSurroundingPairParseTreeBased",description:"Functions",source:"@site/../docs/contributing/api/modules/processTargets_modifiers_surroundingPair_findSurroundingPairParseTreeBased.md",sourceDirName:"contributing/api/modules",slug:"/contributing/api/modules/processTargets_modifiers_surroundingPair_findSurroundingPairParseTreeBased",permalink:"/docs/contributing/api/modules/processTargets_modifiers_surroundingPair_findSurroundingPairParseTreeBased",editUrl:null,tags:[],version:"current",sidebarPosition:0,frontMatter:{id:"processTargets_modifiers_surroundingPair_findSurroundingPairParseTreeBased",title:"Module: processTargets/modifiers/surroundingPair/findSurroundingPairParseTreeBased",sidebar_label:"processTargets/modifiers/surroundingPair/findSurroundingPairParseTreeBased",sidebar_position:0,custom_edit_url:null},sidebar:"contributing",previous:{title:"processTargets/modifiers/surroundingPair/findSurroundingPairCore",permalink:"/docs/contributing/api/modules/processTargets_modifiers_surroundingPair_findSurroundingPairCore"},next:{title:"processTargets/modifiers/surroundingPair/findSurroundingPairTextBased",permalink:"/docs/contributing/api/modules/processTargets_modifiers_surroundingPair_findSurroundingPairTextBased"}},l={},p=[{value:"Functions",id:"functions",level:2},{value:"findSurroundingPairParseTreeBased",id:"findsurroundingpairparsetreebased",level:3},{value:"Parameters",id:"parameters",level:4},{value:"Returns",id:"returns",level:4},{value:"Defined in",id:"defined-in",level:4}],c={toc:p};function g(e){var r=e.components,t=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,n.Z)({},c,t,{components:r,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"functions"},"Functions"),(0,a.kt)("h3",{id:"findsurroundingpairparsetreebased"},"findSurroundingPairParseTreeBased"),(0,a.kt)("p",null,"\u25b8 ",(0,a.kt)("strong",{parentName:"p"},"findSurroundingPairParseTreeBased"),"(",(0,a.kt)("inlineCode",{parentName:"p"},"editor"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"selection"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"node"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"delimiters"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"scopeType"),"): ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," ","|"," ",(0,a.kt)("a",{parentName:"p",href:"/docs/contributing/api/interfaces/processTargets_modifiers_surroundingPair_extractSelectionFromSurroundingPairOffsets.SurroundingPairInfo"},(0,a.kt)("inlineCode",{parentName:"a"},"SurroundingPairInfo"))),(0,a.kt)("p",null,"Implements the version of the surrounding pair finding algorithm that\nleverages the parse tree.  We use this algorithm when we are in a language\nfor which we have parser support, unless we are in a string or comment, where\nwe revert to text-based."),(0,a.kt)("p",null,"The approach is actually roughly the same as the approach we use when we do\nnot have access to a parse tree.  In both cases we create a list of\ncandidate delimiters in the region of the selection, and then pass them to\nthe core algorithm, implemented by findSurroundingPairCore."),(0,a.kt)("p",null,"To generate a list of delimiters to pass to findSurroundingPairCore, we repeatedly walk up the parse tree starting at the given node.  Each time, we ask for all descendant tokens whose type is that of one of the delimiters that we're looking for.\nrepeatedly walk up the parse tree starting at the given node.  Each time, we\nask for all descendant tokens whose type is that of one of the delimiters\nthat we're looking for, and pass this list of tokens to\nfindSurroundingPairCore."),(0,a.kt)("p",null,"Note that walking up the hierarchy one parent at a time is just an\noptimization to avoid handling the entire file if we don't need to.  The\nresult would be the same if we just operated on the root node of the parse\ntree, just slower if our delimiter pair is actually contained in a small\npiece of a large file."),(0,a.kt)("p",null,"The main benefits of the parse tree-based approach over the text-based\napproach are the following:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"We can leverage the lexer to ensure that we only consider proper language tokens"),(0,a.kt)("li",{parentName:"ul"},"We can let the language normalize surface forms of delimiter types, so eg\nin Python the leading ",(0,a.kt)("inlineCode",{parentName:"li"},'f"')," on an f-string just has type ",(0,a.kt)("inlineCode",{parentName:"li"},'"')," like any other\nstring."),(0,a.kt)("li",{parentName:"ul"},"We can more easily narrow the scope of our search by walking up the parse tree"),(0,a.kt)("li",{parentName:"ul"},"The actual lexing is done in fast wasm code rather than using a regex"),(0,a.kt)("li",{parentName:"ul"},"We can disambiguate delimiters whose opening and closing symbol is the\nsame (eg ",(0,a.kt)("inlineCode",{parentName:"li"},'"'),").  Without a parse tree we have to guess whether it is an\nopening or closing quote.")),(0,a.kt)("h4",{id:"parameters"},"Parameters"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,a.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,a.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"editor")),(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("a",{parentName:"td",href:"/docs/contributing/api/interfaces/actions_BringMoveSwap.internal.TextEditor"},(0,a.kt)("inlineCode",{parentName:"a"},"TextEditor"))),(0,a.kt)("td",{parentName:"tr",align:"left"},"The text editor containing the selection")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"selection")),(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("a",{parentName:"td",href:"/docs/contributing/api/classes/actions_BringMoveSwap.internal.Range"},(0,a.kt)("inlineCode",{parentName:"a"},"Range"))),(0,a.kt)("td",{parentName:"tr",align:"left"},"The selection to find surrounding pair around")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"node")),(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("a",{parentName:"td",href:"/docs/contributing/api/interfaces/typings_treeSitter.Parser.SyntaxNode"},(0,a.kt)("inlineCode",{parentName:"a"},"SyntaxNode"))),(0,a.kt)("td",{parentName:"tr",align:"left"},"A parse tree node overlapping with the selection")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"delimiters")),(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("a",{parentName:"td",href:"/docs/contributing/api/modules/typings_targetDescriptor_types#simplesurroundingpairname"},(0,a.kt)("inlineCode",{parentName:"a"},"SimpleSurroundingPairName")),"[]"),(0,a.kt)("td",{parentName:"tr",align:"left"},"The acceptable surrounding pair names")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"scopeType")),(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("a",{parentName:"td",href:"/docs/contributing/api/interfaces/typings_targetDescriptor_types.SurroundingPairScopeType"},(0,a.kt)("inlineCode",{parentName:"a"},"SurroundingPairScopeType"))),(0,a.kt)("td",{parentName:"tr",align:"left"},"-")))),(0,a.kt)("h4",{id:"returns"},"Returns"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"null")," ","|"," ",(0,a.kt)("a",{parentName:"p",href:"/docs/contributing/api/interfaces/processTargets_modifiers_surroundingPair_extractSelectionFromSurroundingPairOffsets.SurroundingPairInfo"},(0,a.kt)("inlineCode",{parentName:"a"},"SurroundingPairInfo"))),(0,a.kt)("p",null,"The newly expanded selection, including editor info"),(0,a.kt)("h4",{id:"defined-in"},"Defined in"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/cursorless-dev/cursorless/blob/24af088/src/processTargets/modifiers/surroundingPair/findSurroundingPairParseTreeBased.ts#L60"},"src/processTargets/modifiers/surroundingPair/findSurroundingPairParseTreeBased.ts:60")))}g.isMDXComponent=!0}}]);